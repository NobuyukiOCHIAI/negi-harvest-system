# ─────────────────────────────────────────────────────────────
# File: routes/predict.py
# Purpose: Prediction endpoints (days & yield) with:
#          - feature-order alignment (meta / preproc / model)
#          - optional preprocessing (DataFrame-based)
#          - backward-compatible single-model /predict
#          - new dual-model /predict_both (days + yield)
#          - both /api/... and legacy ... routes exposed
# ─────────────────────────────────────────────────────────────

from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel, Field
from typing import Any, Dict, List, Optional, Union
import os
import glob
import logging
import traceback
import json

try:
    import joblib
except Exception as e:
    raise RuntimeError("joblib is required to load model .pkl files") from e

try:
    import pandas as pd  # type: ignore
    import numpy as np
except Exception:
    pd = None
    np = None

router = APIRouter()
log = logging.getLogger("xgbapi.predict")

# --- 環境変数設定 ---
MODEL_DIR = os.getenv("MODEL_DIR", "./models")
MODEL_PATH_DAYS = os.getenv("MODEL_PATH_DAYS", os.path.join(MODEL_DIR, "model_days.pkl"))
MODEL_PATH_YIELD = os.getenv("MODEL_PATH_YIELD", os.path.join(MODEL_DIR, "model_yield.pkl"))
FEATURE_META_PATH = os.getenv("FEATURE_META_PATH")
_PREPROC = None  # 今回は preproc.pkl は不要

# --- モデルキャッシュ ---
_MODEL_DAYS = None
_MODEL_YIELD = None
_FEATURE_ORDER: Optional[List[str]] = None


def _load_feature_order():
    """feature_meta.json から feature 順序を取得"""
    global _FEATURE_ORDER
    if not FEATURE_META_PATH or not os.path.isfile(FEATURE_META_PATH):
        log.warning("FEATURE_META_PATH not found or not set")
        return None
    try:
        with open(FEATURE_META_PATH, "r", encoding="utf-8") as f:
            meta = json.load(f)
        if "feature_cols" in meta and isinstance(meta["feature_cols"], list):
            _FEATURE_ORDER = meta["feature_cols"]
            log.info(f"[FEATURE_ORDER] loaded {len(_FEATURE_ORDER)} features from meta file")
            return _FEATURE_ORDER
    except Exception:
        log.exception("Failed to load feature order from meta")
    return None


def _load_models():
    """モデルをロード"""
    global _MODEL_DAYS, _MODEL_YIELD
    if _MODEL_DAYS is None:
        log.info(f"[MODEL_DAYS] loading from {MODEL_PATH_DAYS}")
        _MODEL_DAYS = joblib.load(MODEL_PATH_DAYS)
    if _MODEL_YIELD is None:
        log.info(f"[MODEL_YIELD] loading from {MODEL_PATH_YIELD}")
        _MODEL_YIELD = joblib.load(MODEL_PATH_YIELD)
    return _MODEL_DAYS, _MODEL_YIELD


# --- Pydantic スキーマ ---
class PredictItem(BaseModel):
    features: Dict[str, Any] = Field(..., description="特徴量は feature_meta.json の順序に沿って指定")


class PredictRequest(BaseModel):
    data: List[PredictItem]


class PredictBothResponse(BaseModel):
    model_path_days: str
    model_path_yield: str
    ok: bool
    request_id: Optional[str] = None
    predictions: List[Dict[str, float]]


# --- Utility ---
def _records_to_df(items: List[PredictItem], feature_order: List[str]) -> pd.DataFrame:
    """dict features → DataFrame（欠損は mean 埋め）"""
    if pd is None:
        raise RuntimeError("pandas is required for preprocessing")
    df = pd.DataFrame([{col: it.features.get(col, np.nan) for col in feature_order} for it in items])
    # 欠損を mean で埋める
    for col in df.columns:
        if df[col].isna().any():
            mean_val = df[col].mean()
            df[col] = df[col].fillna(mean_val)
    return df


# --- Endpoints ---
@router.get("/feature_meta")
async def feature_meta():
    order = _FEATURE_ORDER or _load_feature_order()
    return {"ok": True, "feature_order": order}


@router.post("/predict_both", response_model=PredictBothResponse)
async def predict_both(req: PredictRequest, request: Request):
    rid = getattr(request.state, "request_id", None)
    log.info("/predict_both called (rid=%s) records=%d", rid, len(req.data))
    try:
        order = _FEATURE_ORDER or _load_feature_order()
        if not order:
            raise RuntimeError("feature_order is required but not found")
        model_days, model_yield = _load_models()

        df = _records_to_df(req.data, order)

        preds_days = model_days.predict(df)
        preds_yield = model_yield.predict(df)

        predictions = []
        for d, y in zip(preds_days, preds_yield):
            predictions.append({"days": float(d), "yield": float(y)})

        return {
            "ok": True,
            "model_path_days": MODEL_PATH_DAYS,
            "model_path_yield": MODEL_PATH_YIELD,
            "request_id": rid,
            "predictions": predictions
        }
    except Exception as e:
        tb = traceback.format_exc()
        log.error("Prediction failed (rid=%s): %s\n%s", rid, e, tb)
        raise HTTPException(status_code=500, detail={
            "ok": False,
            "error": "prediction_failed",
            "message": str(e),
            "request_id": rid
        })
