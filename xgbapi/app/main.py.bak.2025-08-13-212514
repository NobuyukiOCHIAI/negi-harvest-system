import os, json, logging, logging.config, sys, traceback
from fastapi import FastAPI, Request
from dotenv import load_dotenv
from starlette.responses import Response

# .env をロード
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), "..", "config", ".env"))

# ロギング設定
logconf = os.path.join(os.path.dirname(__file__), "..", "config", "logging.json")
if os.path.exists(logconf):
    with open(logconf) as f:
        logging.config.dictConfig(json.load(f))
logger = logging.getLogger("xgbapi")

# FastAPI アプリ作成
app = FastAPI(title=os.getenv("API_TITLE", "XGB Predict API"))

def _mask_headers_for_log(headers: dict) -> dict:
    masked = dict(headers)
    # APIキーはマスク
    for k in list(masked.keys()):
        if k.lower() in ("x-api-key", "authorization"):
            v = masked.get(k)
            if v:
                masked[k] = "*" * len(v)
    return masked
    
# --- DEBUG Middleware ---
@app.middleware("http")
async def debug_middleware(request: Request, call_next):
    try:
        # 環境変数ログ（API_KEYはマスク）
        api_key_env = os.getenv("API_KEY", "")
        logger.debug(f"ENV: API_TITLE={os.getenv('API_TITLE')}, "
                     f"MODEL_PATH={os.getenv('MODEL_PATH')}, "
                     f"API_KEY={'*' * len(api_key_env) if api_key_env else '(not set)'}")

        # リクエスト情報
        body = await request.body()
        body_str = body.decode(errors="ignore")
        if len(body_str) > 500:
            body_str = body_str[:500] + "...(truncated)"
        logger.debug(
            "REQUEST: %s %s\nHeaders: %s\nBody: %s",
            request.method, request.url,
            _mask_headers_for_log(dict(request.headers)),
            body_str
        )

        # ===== ここが重要：読み込んだボディを再注入 =====
        async def receive():
            return {"type": "http.request", "body": body_bytes, "more_body": False}
        request = Request(request.scope, receive=receive)
        
        # 下流実行
        response = await call_next(request)

        # レスポンス情報
        try:
            resp_body = b""
            async for chunk in response.body_iterator:
                resp_body += chunk

            # Content-Length は付け直させる（不一致事故を避ける）
            new_headers = dict(response.headers)
            new_headers.pop("content-length", None)
            logger.debug(
                "RESPONSE: status=%s, body_len=%d",
                response.status_code, len(resp_body)
            )
            return Response(
                content=resp_body,
                status_code=response.status_code,
                headers=new_headers,
                media_type=response.media_type,
            )

        except Exception as e:
            logger.error(f"Error reading response body: {e}")
            raise

    except Exception:
        logger.error("=== Exception in request processing ===", exc_info=True)
        print("=== predict exception ===", file=sys.stderr, flush=True)
        traceback.print_exc()
        raise
# --- END DEBUG ---

# ルータ登録
from .routes import health, predict
app.include_router(health.router, tags=["meta"])
app.include_router(predict.router, tags=["predict"])
